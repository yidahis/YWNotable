<zhithink>
嗯，用户问的是动态库的加载具体都做了什么。这个问题看起来是关于动态链接库在程序运行时如何被加载和使用的。我需要结合之前提供的参考内容，整理出详细的步骤和机制。

首先，动态库的加载分为隐式加载（静态加载）和显式加载（动态加载）。用户可能想知道这两种方式的区别，以及具体加载过程中操作系统和程序都做了什么操作。根据参考内容，隐式加载在程序启动时由操作系统自动处理，而显式加载则需要通过API手动加载，比如使用dlopen或LoadLibrary。

接下来，动态库加载的具体步骤应该包括几个关键阶段：加载到内存、符号解析、地址重定位、初始化等。需要解释每个阶段的作用，比如加载到内存时如何映射到虚拟地址空间，符号解析如何找到函数地址，重定位如何调整相对地址，以及初始化函数如何执行。

另外，不同的操作系统可能有不同的实现细节，比如Linux的.so文件，Windows的.dll，macOS的.dylib。但用户的问题没有特别指定系统，可能需要概括通用流程，同时提到不同系统的差异。

还要注意动态库的位置无关代码（PIC）的作用，确保库可以在任何地址加载。参考内容中提到使用-fPIC编译选项生成这样的代码，避免绝对地址依赖，这对加载过程很重要。

符号解析和重定位方面，动态链接器需要处理外部符号的绑定，比如在运行时找到printf函数的实际地址。延迟绑定（Lazy Binding）可能也是一个点，比如PLT（过程链接表）和GOT（全局偏移表）的机制，但这些可能在更底层的细节里，是否需要提到呢？

初始化阶段，动态库可能有构造函数（如__attribute__((constructor))）或DllMain函数，这些在加载后执行。参考内容中的iOS例子使用了attribute constructor在main前加载系统库，这部分需要包含在回答里。

还要考虑动态库卸载的过程，引用计数如何工作，比如dlclose减少计数，当计数为零时释放资源。参考内容中提到显式加载时需要成对调用LoadLibrary和FreeLibrary，避免内存泄漏。

可能还需要提到动态库的依赖关系，比如一个库依赖另一个库，动态链接器如何处理递归加载和符号解析。例如，加载B.so时发现它依赖A.so，这时候链接器会先加载A.so，再继续处理B.so。

此外，安全机制如地址空间布局随机化（ASLR）可能会影响动态库的加载地址，这也是加载过程的一部分，确保安全性。

总结一下，动态库的加载流程大致分为加载、符号解析、重定位、初始化四个主要步骤，每个步骤涉及不同的操作系统机制和编译时选项。需要将这些点有条理地组织起来，结合参考内容中的例子和不同系统的实现方式，给出全面具体的回答。
</zhithink>

动态库的加载过程是程序运行时将动态库代码映射到内存并完成符号绑定的核心机制，其具体操作可分为五个阶段：

### 一、物理文件加载
1. **文件路径解析**
   - 隐式加载：通过`LD_LIBRARY_PATH`（Linux）或`@rpath`（macOS）搜索动态库文件
   - 显式加载：`dlopen()`或`LoadLibrary()`直接指定文件路径
   - 示例：
     ```c
     void* handle = dlopen("./libmath.so", RTLD_LAZY); // Linux显式加载
     ```

2. **内存映射**
   - 操作系统将动态库文件映射到进程虚拟地址空间
   - 使用`mmap`系统调用建立虚拟地址与物理内存/磁盘的映射关系
   - 映射区域标记为**只读**（代码段）或**可写**（数据段）

### 二、符号绑定与重定位
1. **符号表解析**
   - 解析`.dynsym`段（动态符号表）获取导出函数/变量地址
   - 通过`.rel.dyn`（数据重定位表）和`.rel.plt`（函数重定位表）修正引用

2. **延迟绑定机制（PLT/GOT）**
   - 首次调用函数时通过**过程链接表（PLT）**跳转到**全局偏移表（GOT）**
   - GOT初始指向动态链接器的`_dl_runtime_resolve`函数
   ```asm
   ; x86_64 PLT示例
   foo@plt:
       jmp *GOT[1]    ; 首次跳转至解析函数
       push index     
       jmp .plt      ; 触发符号解析
   ```

3. **地址随机化（ASLR）**
   - 加载基址添加随机偏移（Linux默认±4MB范围）
   - 防止内存攻击，但需配合`-fPIC`编译选项

### 三、初始化执行
1. **初始化函数调用**
   - 执行`.init_array`段中的构造函数（优先级控制）
   - 调用`__attribute__((constructor))`修饰的函数
   ```c
   __attribute__((constructor(101))) 
   void lib_init() { 
       printf("Library initializing\n"); 
   }
   ```

2. **线程局部存储（TLS）**
   - 为每个线程分配独立的`.tdata`和`.tbss`段副本
   - 使用`__thread`关键字声明线程局部变量

### 四、运行时管理
1. **引用计数机制**
   - 多次`dlopen()`同一库会增加引用计数
   - `dlclose()`减少计数，归零时触发卸载
   ```c
   void* h1 = dlopen("lib.so", RTLD_GLOBAL); // 计数+1
   void* h2 = dlopen("lib.so", RTLD_GLOBAL); // 计数+2
   dlclose(h1); // 计数-1
   ```

2. **依赖库递归加载**
   - 动态解析`DT_NEEDED`段记录的依赖库
   - 广度优先加载策略避免循环依赖

### 五、系统级优化
1. **共享内存机制**
   - 多个进程共享同一物理内存中的代码段（`MAP_SHARED`）
   - 修改`.got.plt`实现不同进程数据段隔离

2. **性能对比指标**
   | 操作                | 耗时（x86_64） | 内存开销 |
   |---------------------|----------------|----------|
   | 动态库加载          | 0.5-5ms        | 虚拟内存 |
   | 符号延迟绑定        | 50-200ns/次    | 无       |
   | 预加载（LD_PRELOAD）| 减少30%延迟    | 固定内存 |

动态库加载实现了代码复用与模块化，但也带来兼容性风险（如ABI版本冲突）。实际开发中建议通过`nm -D`检查导出符号，使用`patchelf`工具修改动态库依赖路径，并通过`LD_DEBUG=files`环境变量调试加载过程。
